<!doctype html public "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <style type="text/css">
    body { font-family: Verdana, Geneva, Arial, Helvetica, serif;
           color: #000000;
           background: #FFFFFF; }

    p { text-align: justify; }
    h1 { text-align: center; }
    li { text-align: justify; }
    td { padding: 0 0.5em 0 0.5em; }

    a:link { color: #0000EF; }
    a:visited { color: #51188E; }
    a:hover { color: #FF0000; }

    div.pre { font-family: monospace;
              text-align:  left;
              white-space: pre;
              color:       blue; }

    span.comment { color: gray; }
  </style>
  <meta http-equiv="Content-Type"
        content="text/html; charset=iso-8859-1">
  <meta name="Author"
        content="David Turner">
  <title>FreeType 2 Tutorial</title>
</head>

<body text="#000000"
      bgcolor="#FFFFFF"
      link="#0000EF"
      vlink="#51188E"
      alink="#FF0000">

<h1 align=center>
  FreeType 2 Tutorial<br>
  Step&nbsp;1 &mdash; simple glyph loading
</h1>

<h3 align=center>
  &copy; 2003, 2006, 2007 David Turner
    (<a href="mailto:david@freetype.org">david@freetype.org</a>)<br>
  &copy; 2003, 2006, 2007 The FreeType Development Team
    (<a href="http://www.freetype.org">www.freetype.org</a>)
</h3>

<center>
<table width="70%">
<tr><td>

  <hr>

  <h2>
    Introduction
  </h2>

  <p>This is the first section of the FreeType 2 tutorial.  It will teach
  you how to:</p>

  <ul>
    <li>initialize the library</li>
    <li>open a font file by creating a new face object</li>
    <li>select a character size in points or in pixels</li>
    <li>load a single glyph image and convert it to a bitmap</li>
    <li>render a very simple string of text</li>
    <li>render a rotated string of text easily</li>
  </ul>

  <hr>

    <h3>
      1.&nbsp;Header files
    </h3>

    <p>The following are instructions required to compile an application that
    uses the FreeType&nbsp;2 library.</p>

    <ol>
      <li>
        <p><b><font size="+1">Locate the FreeType&nbsp;2 <tt>include</tt>
        directory.</font></b><br></p>

        <p>You have to add it to your compilation include path.</p>

        <p>Note that on Unix systems, you can now run the
        <tt>freetype-config</tt> script with the <tt>--cflags</tt> option to
        retrieve the appropriate compilation flags.  This script can also be
        used to check the version of the library that is installed on your
        system, as well as the required librarian and linker flags.</p>
      </li>

      <li>
        <p><b><font size="+1">Include the file named
        <tt>ft2build.h</tt>.</font></b></p>

        <p>It contains various macro declarations that are later used to
        <tt>#include</tt> the appropriate public FreeType&nbsp;2 header
        files.</p>
      </li>

      <li>
        <p><b><font size="+1">Include the main FreeType&nbsp;2 API header
        file.</font></b></p>

        <p>You should do that using the macro <tt>FT_FREETYPE_H</tt>,
        like in the following example:</p>

        <div class="pre">
  #include &lt;ft2build.h&gt;
  #include FT_FREETYPE_H
        </div>

        <p><tt>FT_FREETYPE_H</tt> is a special macro defined in the file
        <tt>ftheader.h</tt>.  It contains some installation-specific macros
        to name other public header files of the FreeType&nbsp;2 API.</p>

        <p>You can read <a
        href="../reference/ft2-header_file_macros.html">this section of the
        FreeType&nbsp;2 API Reference</a> for a complete listing of the
        header macros.</p>
      </li>
    </ol>

    <p>The use of macros in <tt>#include</tt> statements is ANSI-compliant.
    It is used for several reasons:</p>

    <ul>
      <li>
        <p>It avoids some painful conflicts with the FreeType 1.x public
        header files.</p>
      </li>

      <li>
        <p>The macro names are not limited to the DOS 8.3 file naming limit;
        names like <tt>FT_MULTIPLE_MASTERS_H</tt> or <tt>FT_SFNT_NAMES_H</tt>
        are a lot more readable and explanatory than the real file names
        <tt>ftmm.h</tt> and <tt>ftsnames.h</tt>.</p>
      </li>

      <li>
        <p>It allows special installation tricks that will not be discussed
        here.</p>
      </li>
    </ul>

    <p><font color="red">NOTE: Starting with FreeType&nbsp;2.1.6, the old
    header file inclusion scheme is no longer supported.  This means that
    you now get an error if you do something like the following:</font></p>

    <div class="pre">
  #include &lt;freetype/freetype.h&gt;
  #include &lt;freetype/ftglyph.h&gt;
  ...
    </div>

    <hr>


    <h3>
      2.&nbsp;Initialize the library
    </h3>

    <p>Simply create a variable of type <a
    href="../reference/ft2-base_interface.html#FT_Library">
    <tt>FT_Library</tt></a> named, for example, <tt>library</tt>, and call
    the function <a
    href="../reference/ft2-base_interface.html#FT_Init_FreeType">
    <tt>FT_Init_FreeType</tt></a> as in</p>

    <div class="pre">
  #include &lt;ft2build.h&gt;
  #include FT_FREETYPE_H

  FT_Library  library;


  ...

  error = FT_Init_FreeType( &amp;library );
  if ( error )
  {
    ... an error occurred during library initialization ...
  }
    </div>

    <p>This function is in charge of the following:</p>

    <ul>
      <li>
        <p>It creates a new instance of the FreeType&nbsp;2 library, and
        sets the handle <tt>library</tt> to it.</p>
      </li>

      <li>
        <p>It loads each module that FreeType knows about in the library.
        Among others, your new <tt>library</tt> object is able
        to handle TrueType, Type&nbsp;1, CID-keyed &amp; OpenType/CFF fonts
        gracefully.</p>
      </li>
    </ul>

    <p>As you can see, the function returns an error code, like most others
    in the FreeType API.  An error code of&nbsp;0 <em>always</em> means that
    the operation was successful; otherwise, the value describes the error,
    and <tt>library</tt> is set to NULL.</p>

    <hr>


    <h3>
      3.&nbsp;Load a font face
    </h3>

      <h4>
        a.&nbsp;From a font file
      </h4>

      <p>Create a new <tt>face</tt> object by calling <a
      href="../reference/ft2-base_interface.html#FT_New_Face">
      <tt>FT_New_Face</tt></a>.  A <em>face</em> describes a given typeface
      and style.  For example, &lsquo;Times New Roman Regular&rsquo; and
      &lsquo;Times New Roman Italic&rsquo; correspond to two different
      faces.</p>

      <div class="pre">
  FT_Library  library;   <span class="comment">/* handle to library     */</span>
  FT_Face     face;      <span class="comment">/* handle to face object */</span>


  error = FT_Init_FreeType( &amp;library );
  if ( error ) { ... }

  error = FT_New_Face( library,
                       "/usr/share/fonts/truetype/arial.ttf",
                       0,
                       &amp;face );
  if ( error == FT_Err_Unknown_File_Format )
  {
    ... the font file could be opened and read, but it appears
    ... that its font format is unsupported
  }
  else if ( error )
  {
    ... another error code means that the font file could not
    ... be opened or read, or simply that it is broken...
  }
      </div>

      <p>As you can certainly imagine, <tt>FT_New_Face</tt> opens a font
      file, then tries to extract one face from it.  Its parameters are</p>

      <table cellpadding=5>
        <tr valign="top">
          <td>
            <tt>library</tt>
          </td>
          <td>
            <p>A handle to the FreeType library instance where the face object
            is created.</p>
          </td>
        </tr>
        <tr valign="top">
          <td>
            <tt>filepathname</tt>
          </td>
          <td>
            <p>The font file pathname (a standard C string).</p>
          </td>
        </tr>
        <tr valign="top">
          <td>
            <tt>face_index</tt>
          </td>
          <td>
            <p>Certain font formats allow several font faces to be embedded
            in a single file.</p>

            <p>This index tells which face you want to load.  An error will
            be returned if its value is too large.</p>

            <p>Index&nbsp;0 always work though.</p>
          </td>
        </tr>
        <tr valign="top">
          <td>
            <tt>face</tt>
          </td>
          <td>
            <p>A <em>pointer</em> to the handle that will be set to describe
            the new face object.</p>

            <p>It is set to NULL in case of error.</p>
          </td>
        </tr>
      </table>

      <p>To know how many faces a given font file contains, simply load its
      first face (this is, <tt>face_index</tt> should be set to zero), then
      check the value of <tt>face-&gt;num_faces</tt> which indicates how
      many faces are embedded in the font file.</p>

      <h4>
        b.&nbsp;From memory
      </h4>

      <p>In the case where you have already loaded the font file into memory,
      you can similarly create a new face object for it by calling <a
      href="../reference/ft2-base_interface.html#FT_New_Memory_Face">
      <tt>FT_New_Memory_Face</tt></a> as in</p>

      <div class="pre">
  FT_Library  library;   <span class="comment">/* handle to library     */</span>
  FT_Face     face;      <span class="comment">/* handle to face object */</span>


  error = FT_Init_FreeType( &amp;library );
  if ( error ) { ... }

  error = FT_New_Memory_Face( library,
                              buffer,    <span class="comment">/* first byte in memory */</span>
                              size,      <span class="comment">/* size in bytes        */</span>
                              0,         <span class="comment">/* face_index           */</span>
                              &amp;face );
  if ( error ) { ... }
      </div>

      <p>As you can see, <tt>FT_New_Memory_Face</tt> simply takes a pointer
      to the font file buffer and its size in bytes instead of a file
      pathname.  Other than that, it has exactly the same semantics as
      <tt>FT_New_Face</tt>.</p>

      <p>Note that you must not deallocate the memory before calling
      <tt>FT_Done_Face</tt>.</p>

      <h4>
        c.&nbsp;From other sources (compressed files, network, etc.)
      </h4>

      <p>There are cases where using a file pathname or preloading the file
      into memory is simply not sufficient.  With FreeType&nbsp;2, it is
      possible to provide your own implementation of i/o routines.</p>

      <p>This is done through the <a
      href="../reference/ft2-base_interface.html#FT_Open_Face">
      <tt>FT_Open_Face</tt></a> function, which can be used to open a new
      font face with a custom input stream, select a specific driver for
      opening, or even pass extra parameters to the font driver when creating
      the object.  We advise you to refer to the FreeType&nbsp;2 reference
      manual in order to learn how to use it.</p>

      <hr>

    <h3>
      4.&nbsp;Accessing face content
    </h3>

    <p>A <em>face object</em> models all information that globally describes
    the face.  Usually, this data can be accessed directly by dereferencing
    a handle, like in <tt>face&minus;&gt;num_glyphs</tt>.</p>

    <p>The complete list of available fields in in the <a
    href="../reference/ft2-base_interface.html#FT_FaceRec">
    <tt>FT_FaceRec</tt></a> structure description.  However, we describe
    here a few of them in more details:
    </p>

    <table cellpadding=5>
      <tr valign="top">
        <td>
          <tt>num_glyphs</tt>
        </td>
        <td>
          <p>This variable gives the number of <em>glyphs</em> available in
          the font face.  A glyph is simply a character image.  It doesn't
          necessarily correspond to a <em>character code</em> though.</p>
        </td>
      </tr>
      <tr valign="top">
        <td>
          <tt>flags</tt>
        </td>
        <td>
          <p>A 32-bit integer containing bit flags used to describe some
          face properties.  For example, the flag
          <tt>FT_FACE_FLAG_SCALABLE</tt> is used to indicate that the face's
          font format is scalable and that glyph images can be rendered for
          all character pixel sizes.  For more information on face flags,
          please read the <a
          href="../reference/ft2-index.html">FreeType&nbsp;2 API
          Reference</a>.</p>
        </td>
      </tr>
      <tr valign="top">
        <td>
          <tt>units_per_EM</tt>
        </td>
        <td>
          <p>This field is only valid for scalable formats (it is set
          to&nbsp;0 otherwise).  It indicates the number of font units
          covered by the EM.</p>
        </td>
      </tr>
      <tr valign="top">
        <td>
          <tt>num_fixed_sizes</tt>
        </td>
        <td>
          <p>This field gives the number of embedded bitmap strikes
          in the current face.  A <em>strike</em> is simply a series of
          glyph images for a given character pixel size.  For example, a
          font face could include strikes for pixel sizes 10, 12
          and&nbsp;14.  Note that even scalable font formats can have
          embedded bitmap strikes!</p>
        </td>
      </tr>
      <tr valign="top">
        <td>
          <tt>fixed_sizes</tt>
        </td>
        <td>
          <p>A pointer to an array of <tt>FT_Bitmap_Size</tt>
          elements.  Each <tt>FT_Bitmap_Size</tt> indicates the horizontal
          and vertical <em>character pixel sizes</em> for each of the strikes
          that are present in the face.</p>

          <p><font color="red">Note that, generally speaking, these are
          <em>not</em> the <em>cell size</em> of the bitmap strikes.</font>
          </p>
        </td>
      </tr>
    </table>

    <hr>

    <h3>
      5.&nbsp;Setting the current pixel size
    </h3>

    <p>FreeType&nbsp;2 uses <em>size objects</em> to model all information
    related to a given character size for a given face.  For example, a size
    object will hold the value of certain metrics like the ascender or text
    height, expressed in 1/64th of a pixel, for a character size of
    12&nbsp;points.</p>

    <p>When the <tt>FT_New_Face</tt> function is called (or one of its
    cousins), it <em>automatically</em> creates a new size object for the
    returned face.  This size object is directly accessible as
    <tt>face&minus;&gt;size</tt>.</p>

    <p><em>NOTE: A single face object can deal with one or more size
    objects at a time; however, this is something that few programmers
    really need to do.  We have thus decided to simplify the API for the
    most common use (i.e., one size per face) while keeping this feature
    available through additional functions.</em></p>

    <p>When a new face object is created, all elements are set to&nbsp;0
    during initialization.  To populate the structure with sensible values,
    simply call <a
    href="../reference/ft2-base_interface.html#FT_Set_Char_Size">
    <tt>FT_Set_Char_Size</tt></a>.  Here is an example where the character
    size is set to 16pt for a 300&times;300dpi device:</p>

    <div class="pre">
  error = FT_Set_Char_Size(
            face,    <span class="comment">/* handle to face object           */</span>
            0,       <span class="comment">/* char_width in 1/64th of points  */</span>
            16*64,   <span class="comment">/* char_height in 1/64th of points */</span>
            300,     <span class="comment">/* horizontal device resolution    */</span>
            300 );   <span class="comment">/* vertical device resolution      */</span>
    </div>

    <p>Some notes:</p>

    <ul>
      <li>
        <p>The character widths and heights are specified in 1/64th of
        points.  A point is a <em>physical</em> distance, equaling 1/72th
        of an inch.  Normally, it is not equivalent to a pixel.<p>
      </li>

      <li>
        <p>The horizontal and vertical device resolutions are expressed in
        <em>dots-per-inch</em>, or <em>dpi</em>.  Normal values are 72 or
        96&nbsp;dpi for display devices like the screen.  The resolution
        is used to compute the character pixel size from the character
        point size.</p>
      </li>

      <li>
        <p>A value of&nbsp;0 for the character width means &lsquo;same as
        character height&rsquo;, a value of&nbsp;0 for the character height
        means &lsquo;same as character width&rsquo;.  Otherwise, it is
        possible to specify different character widths and heights.</p>
      </li>

      <li>
        <p>A value of&nbsp;0 for the horizontal resolution means
        &lsquo;same as vertical resolution&rsquo;, a value of&nbsp;0 for the
        vertical resolution means &lsquo;same as horizontal
        resolution&rsquo;.  If both values are zero, 72&nbsp;dpi is used for
        both dimensions.</p>
      </li>

      <li>
        <p>The first argument is a handle to a face object, not a size
        object.</p>
      </li>
    </ul>

    <p>This function computes the character pixel size that corresponds to
    the character width and height and device resolutions.  However, if you
    want to specify the pixel sizes yourself, you can simply call
    <a href="../reference/ft2-base_interface.html#FT_Set_Pixel_Sizes">
    <tt>FT_Set_Pixel_Sizes</tt></a>, as in</p>

    <div class="pre">
  error = FT_Set_Pixel_Sizes(
            face,   <span class="comment">/* handle to face object */</span>
            0,      <span class="comment">/* pixel_width           */</span>
            16 );   <span class="comment">/* pixel_height          */</span>
    </div>

    <p>This example will set the character pixel sizes to
    16&times;16&nbsp;pixels.  As previously, a value of&nbsp;0 for one of
    the dimensions means &lsquo;same as the other&rsquo;.</p>

    <p>Note that both functions return an error code.  Usually, an error
    occurs with a fixed-size font format (like FNT or PCF) when trying to
    set the pixel size to a value that is not listed in the
    <tt>face-&gt;fixed_sizes</tt> array.</p>

    <hr>

    <h3>
      6.&nbsp;Loading a glyph image
    </h3>

      <h4>
        a.&nbsp;Converting a character code into a glyph index
      </h4>

      <p>Usually, an application wants to load a glyph image based on its
      <em>character code</em>, which is a unique value that defines the
      character for a given <em>encoding</em>.  For example, the character
      code&nbsp;65 represents the &lsquo;A&rsquo; in ASCII encoding.</p>

      <p>A face object contains one or more tables, called
      <em>charmaps</em>, that are used to convert character codes to glyph
      indices.  For example, most TrueType fonts contain two charmaps.  One
      is used to convert Unicode character codes to glyph indices, the other
      is used to convert Apple Roman encoding into glyph indices.  Such
      fonts can then be used either on Windows (which uses Unicode) and
      Macintosh (which uses Apple Roman).  Note also that a given
      charmap might not map to all the glyphs present in the font.</p>

      <p>By default, when a new face object is created, it selects a
      Unicode charmap.  FreeType tries to emulate a Unicode charmap if the
      font doesn't contain such a charmap, based on glyph names.  Note that
      it is possible that the emulation misses glyphs if glyph names are
      non-standard.  For some fonts, including symbol fonts and (older)
      fonts for Asian scripts, no Unicode emulation is possible at all.</p>

      <p>We will describe later how to look for specific charmaps in a face.
      For now, we will assume that the face contains at least a Unicode
      charmap that was selected during a call to <tt>FT_New_Face</tt>.  To
      convert a Unicode character code to a font glyph index, we use
      <tt>FT_Get_Char_Index</tt>, as in</p>

      <div class="pre">
  glyph_index = FT_Get_Char_Index( face, charcode );
      </div>

      <p>This will look the glyph index corresponding to the given
      <tt>charcode</tt> in the charmap that is currently selected for the
      face.  If no charmap was selected, the function simply returns the
      charcode.</p>

      <p>Note that this is one of the rare FreeType functions that do not
      return an error code.  However, when a given character code has no
      glyph image in the face, the value&nbsp;0 is returned.  By convention,
      it always correspond to a special glyph image called the <em>missing
      glyph</em>, which is commonly displayed as a box or a space.</p>

      <h4>
        b.&nbsp;Loading a glyph from the face
      </h4>

      <p>Once you have a glyph index, you can load the corresponding glyph
      image.  The latter can be stored in various formats within the font
      file.  For fixed-size formats like FNT or PCF, each image is a bitmap.
      Scalable formats like TrueType or Type&nbsp;1 use vectorial shapes,
      named <em>outlines</em> to describe each glyph.  Some formats may have
      even more exotic ways of representing glyphs (e.g., MetaFont &mdash;
      but this format is not supported).  Fortunately, FreeType&nbsp;2 is
      flexible enough to support any kind of glyph format through a simple
      API.</p>

      <p>The glyph image is always stored in a special object called a
      <em>glyph slot</em>.  As its name suggests, a glyph slot is simply a
      container that is able to hold one glyph image at a time, be it a
      bitmap, an outline, or something else.  Each face object has a single
      glyph slot object that can be accessed as <tt>face-&gt;glyph</tt>.
      Its fields are explained by the <a
      href="../reference/ft2-base_interface.html#FT_GlyphSlotRec">
      <tt>FT_GlyphSlotRec</tt></a> structure documentation.</p>

      <p>Loading a glyph image into the slot is performed by calling <a
      href="../reference/ft2-base_interface.html#FT_Load_Glyph">
      <tt>FT_Load_Glyph</tt></a> as in</p>

      <div class="pre">
  error = FT_Load_Glyph(
            face,          <span class="comment">/* handle to face object */</span>
            glyph_index,   <span class="comment">/* glyph index           */</span>
            load_flags );  <span class="comment">/* load flags, see below */</span>
      </div>

      <p>The <tt>load_flags</tt> value is a set of bit flags used to
      indicate some special operations.  The default value
      <tt>FT_LOAD_DEFAULT</tt> is&nbsp;0.</p>

      <p>This function will try to load the corresponding glyph image
      from the face:</p>

      <ul>
        <li>
          <p>If a bitmap is found for the corresponding glyph and pixel
          size, it will be loaded into the slot.  Embedded bitmaps are
          always favored over native image formats, because we assume that
          they are higher-quality versions of the same glyph.  This can be
          changed by using the <tt>FT_LOAD_NO_BITMAP</tt> flag.</p>
        </li>

        <li>
          <p>Otherwise, a native image for the glyph will be loaded.  It
          will also be scaled to the current pixel size, as well as hinted
          for certain formats like TrueType and Type&nbsp;1.</p>
        </li>
      </ul>

      <p>The field <tt>face&minus;&gt;glyph&minus;&gt;format</tt> describes
      the format used to store the glyph image in the slot.  If it is not
      <tt>FT_GLYPH_FORMAT_BITMAP</tt>, one can immediately convert it to a
      bitmap through <a
      href="../reference/ft2-base_interface.html#FT_Render_Glyph">
      <tt>FT_Render_Glyph</tt></a> as in:</p>

      <div class="pre">
  error = FT_Render_Glyph( face-&gt;glyph,   <span class="comment">/* glyph slot  */</span>
                           render_mode ); <span class="comment">/* render mode */</span>
      </div>

      <p>The parameter <tt>render_mode</tt> is a set of bit flags used to
      specify how to render the glyph image.  Set it to
      <tt>FT_RENDER_MODE_NORMAL</tt> to render a high-quality anti-aliased
      (256 gray levels) bitmap, as this is the default.  You can
      alternatively use <tt>FT_RENDER_MODE_MONO</tt> if you want to generate
      a 1-bit monochrome bitmap.</p>

      <p>Once you have a bitmapped glyph image, you can access it directly
      through <tt>glyph-&gt;bitmap</tt> (a simple bitmap descriptor), and
      position it through <tt>glyph-&gt;bitmap_left</tt> and
      <tt>glyph-&gt;bitmap_top</tt>.</p>

      <p>Note that <tt>bitmap_left</tt> is the horizontal distance from the
      current pen position to the leftmost border of the glyph bitmap, while
      <tt>bitmap_top</tt> is the vertical distance from the pen position (on
      the baseline) to the topmost border of the glyph bitmap.  <em>It is
      positive to indicate an upwards distance</em>.</p>

      <p>The next section will give more details on the contents of a glyph
      slot and how to access specific glyph information (including
      metrics).</p>

      <h4>
        c.&nbsp;Using other charmaps
      </h4>

      <p>As said before, when a new face object is created, it will look for
      a Unicode charmap and select it.  The currently selected charmap is
      accessed via <tt>face-&gt;charmap</tt>.  This field is NULL when no
      charmap is selected, which typically happens when you create a new
      <tt>FT_Face</tt> object from a font file that doesn't contain a
      Unicode charmap (which is rather infrequent today).</p>

      <p>There are two ways to select a different charmap with
      FreeType&nbsp;2.  The easiest is when the encoding you need already
      has a corresponding enumeration defined in <tt>FT_FREETYPE_H</tt>, for
      example <tt>FT_ENCODING_BIG5</tt>.  In this case, you can simply call
      <a href="../reference/ft2-base_interface.html#FT_Select_CharMap">
      <tt>FT_Select_CharMap</tt></a> as in:</p>

      <div class="pre">
  error = FT_Select_CharMap(
            face,               <span class="comment">/* target face object */</span>
            FT_ENCODING_BIG5 ); <span class="comment">/* encoding           */</span>
      </div>

      <p>Another way is to manually parse the list of charmaps for the face;
      this is accessible through the fields <tt>num_charmaps</tt> and
      <tt>charmaps</tt> (notice the &lsquo;s&rsquo) of the face object.  As
      you could expect, the first is the number of charmaps in the face,
      while the second is <em>a table of pointers to the charmaps</em>
      embedded in the face.</p>

      <p>Each charmap has a few visible fields used to describe it more
      precisely.  Mainly, one will look at <tt>charmap-&gt;platform_id</tt>
      and <tt>charmap-&gt;encoding_id</tt> that define a pair of values
      that can be used to describe the charmap in a rather generic way.</p>

      <p>Each value pair corresponds to a given encoding.  For example, the
      pair (3,1) corresponds to Unicode.  The list is defined in the
      TrueType specification but you can also use the file
      <tt>FT_TRUETYPE_IDS_H</tt> which defines several helpful constants to
      deal with them.</p>

      <p>To select a specific encoding, you need to find a corresponding
      value pair in the specification, then look for it in the charmaps
      list.  Don't forget that there are encodings which correspond to
      several value pairs due to historical reasons.  Here some code to do
      it:</p>

      <div class="pre">
  FT_CharMap  found = 0;
  FT_CharMap  charmap;
  int         n;


  for ( n = 0; n &lt; face-&gt;num_charmaps; n++ )
  {
    charmap = face-&gt;charmaps[n];
    if ( charmap-&gt;platform_id == my_platform_id &amp;&amp;
         charmap-&gt;encoding_id == my_encoding_id )
    {
      found = charmap;
      break;
    }
  }

  if ( !found ) { ... }

  <span class="comment">/* now, select the charmap for the face object */</span>
  error = FT_Set_CharMap( face, found );
  if ( error ) { ... }
      </div>

      <p>Once a charmap has been selected, either through
      <tt>FT_Select_CharMap</tt> or <tt>FT_Set_CharMap</tt>, it is used by
      all subsequent calls to <tt>FT_Get_Char_Index</tt>.</p>

      <h4>
        d.&nbsp;Glyph transformations
      </h4>

      <p>It is possible to specify an affine transformation to be applied to
      glyph images when they are loaded.  Of course, this will only work for
      scalable (vectorial) font formats.</p>

      <p>To do that, simply call <a
      href="../reference/ft2-base_interface.html#FT_Set_Transform">
      <tt>FT_Set_Transform</tt></a>, as in:</p>

      <div class="pre">
  error = FT_Set_Transform(
            face,       <span class="comment">/* target face object    */</span>
            &amp;matrix,    <span class="comment">/* pointer to 2x2 matrix */</span>
            &amp;delta );   <span class="comment">/* pointer to 2d vector  */</span>
      </div>

      <p>This function will set the current transform for a given face
      object.  Its second parameter is a pointer to a simple <a
      href="../reference/ft2-basic_types.html#FT_Matrix">
      <tt>FT_Matrix</tt></a> structure that describes a 2&times;2 affine
      matrix.  The third parameter is a pointer to a <a
      href="../reference/ft2-basic_types.html#FT_Vector">
      <tt>FT_Vector</tt></a> structure that describes a simple
      two-dimensional vector that is used to translate the glyph image
      <em>after</em> the 2&times;2 transformation.</p>

      <p>Note that the matrix pointer can be set to NULL, in which case the
      identity transform will be used.  Coefficients of the matrix are
      otherwise in 16.16 fixed float units.</p>

      <p>The vector pointer can also be set to NULL (in which case a delta
      of (0,0) will be used).  The vector coordinates are expressed in
      1/64th of a pixel (also known as 26.6 fixed floats).</p>

      <p><font color="red">NOTE: The transformation is applied to every
      glyph that is loaded through <tt>FT_Load_Glyph</tt> and is
      <em>completely independent of any hinting process</em>.  This means
      that you won't get the same results if you load a glyph at the size of
      24&nbsp;pixels, or a glyph at the size at 12&nbsp;pixels scaled
      by&nbsp;2 through a transform, because the hints will have been
      computed differently (except you have disabled hints).</font></p>

      <p>If you ever need to use a non-orthogonal transformation with
      optimal hints, you first have to decompose your transformation into a
      scaling part and a rotation/shearing part.  Use the scaling part to
      compute a new character pixel size, then the other one to call
      <tt>FT_Set_Transform</tt>.  This is explained in details in a later
      section of this tutorial.</p>

      <p>Loading a glyph bitmap with a non-identity transformation works;
      the transformation is ignored in this case.</p>

    <hr>

    <h3>
      7.&nbsp;Simple text rendering
    </h3>

    <p>We will now present a very simple example used to render a string of
    8-bit Latin-1 text, assuming a face that contains a Unicode charmap</p>

    <p>The idea is to create a loop that will, on each iteration, load one
    glyph image, convert it to an anti-aliased bitmap, draw it on the target
    surface, then increment the current pen position.</p>

      <h4>
        a.&nbsp;Basic code
      </h4>

      <p>The following code performs our simple text rendering with the
      functions previously described.</p>

      <div class="pre">
  FT_GlyphSlot  slot = face-&gt;glyph;  <span class="comment">/* a small shortcut */</span>
  int           pen_x, pen_y, n;


  ... initialize library ...
  ... create face object ...
  ... set character size ...

  pen_x = 300;
  pen_y = 200;

  for ( n = 0; n &lt; num_chars; n++ )
  {
    FT_UInt  glyph_index;


    <span class="comment">/* retrieve glyph index from character code */</span>
    glyph_index = FT_Get_Char_Index( face, text[n] );

    <span class="comment">/* load glyph image into the slot (erase previous one) */</span>
    error = FT_Load_Glyph( face, glyph_index, FT_LOAD_DEFAULT );
    if ( error )
      continue;  <span class="comment">/* ignore errors */</span>

    <span class="comment">/* convert to an anti-aliased bitmap */</span>
    error = FT_Render_Glyph( face-&gt;glyph, FT_RENDER_MODE_NORMAL );
    if ( error )
      continue;

    <span class="comment">/* now, draw to our target surface */</span>
    my_draw_bitmap( &amp;slot-&gt;bitmap,
                    pen_x + slot-&gt;bitmap_left,
                    pen_y - slot-&gt;bitmap_top );

    <span class="comment">/* increment pen position */</span>
    pen_x += slot-&gt;advance.x >> 6;
    pen_y += slot-&gt;advance.y >> 6; <span class="comment">/* not useful for now */</span>
  }
      </div>

      <p>This code needs a few explanations:</p>

      <ul>
        <li>
          <p>We define a handle named <tt>slot</tt> that points to the
          face object's glyph slot.  (The type <tt>FT_GlyphSlot</tt> is
          a pointer).  That is a convenience to avoid using
          <tt>face-&gt;glyph-&gt;XXX</tt> every time.</p>
        </li>

        <li>
          <p>We increment the pen position with the vector
          <tt>slot-&gt;advance</tt>, which correspond to the glyph's
          <em>advance width</em> (also known as its <em>escapement</em>).
          The advance vector is expressed in 1/64th of pixels, and is
          truncated to integer pixels on each iteration.</p>
        </li>

        <li>
          <p>The function <tt>my_draw_bitmap</tt> is not part of FreeType
          but must be provided by the application to draw the bitmap to the
          target surface.  In this example, it takes a pointer to a
          FT_Bitmap descriptor and the position of its top-left corner as
          arguments.</p>
        </li>

        <li>
          <p>The value of <tt>slot-&gt;bitmap_top</tt> is positive for an
          <em>upwards</em> vertical distance.  Assuming that the coordinates
          taken by <tt>my_draw_bitmap</tt> use the opposite convention
          (increasing&nbsp;Y corresponds to downwards scanlines), we
          subtract it from <tt>pen_y</tt>, instead of adding to it.</p>
        </li>
      </ul>

      <h4>
        b.&nbsp;Refined code
      </h4>

      <p>The following code is a refined version of the example above.  It
      uses features and functions of FreeType&nbsp;2 that have not yet been
      introduced, and which are explained below:</p>

      <div class="pre">
  FT_GlyphSlot  slot = face-&gt;glyph;  <span class="comment">/* a small shortcut */</span>
  FT_UInt       glyph_index;
  int           pen_x, pen_y, n;


  ... initialize library ...
  ... create face object ...
  ... set character size ...

  pen_x = 300;
  pen_y = 200;

  for ( n = 0; n &lt; num_chars; n++ )
  {
    <span class="comment">/* load glyph image into the slot (erase previous one) */</span>
    error = FT_Load_Char( face, text[n], FT_LOAD_RENDER );
    if ( error )
      continue;  <span class="comment">/* ignore errors */</span>

    <span class="comment">/* now, draw to our target surface */</span>
    my_draw_bitmap( &amp;slot-&gt;bitmap,
                    pen_x + slot-&gt;bitmap_left,
                    pen_y - slot-&gt;bitmap_top );

    <span class="comment">/* increment pen position */</span>
    pen_x += slot-&gt;advance.x >> 6;
  }
      </div>

      <p>We have reduced the size of our code, but it does exactly the
      same thing:</p>

      <ul>
        <li>
          <p>We use the function <tt>FT_Load_Char</tt> instead of
          <tt>FT_Load_Glyph</tt>.  As you probably imagine, it is equivalent
          to calling <tt>FT_Get_Char_Index</tt> then
          <tt>FT_Get_Load_Glyph</tt>.</p>
        </li>

        <li>
          <p>We do not use <tt>FT_LOAD_DEFAULT</tt> for the loading mode,
          but the bit flag <tt>FT_LOAD_RENDER</tt>.  It indicates that the
          glyph image must be immediately converted to an anti-aliased
          bitmap.  This is of course a shortcut that avoids calling
          <tt>FT_Render_Glyph</tt> explicitly but is strictly
          equivalent.</p>

          <p>Note that you can also specify that you want a monochrome
          bitmap instead by using the addition <tt>FT_LOAD_MONOCHROME</tt>
          load flag.</p>
        </li>
      </ul>

    <h4>
      c.&nbsp;More advanced rendering
    </h4>

    <p>Let us try to render transformed text now (for example through a
    rotation).  We can do this using <tt>FT_Set_Transform</tt>.  Here is how
    to do it:</p>

    <div class="pre">
  FT_GlyphSlot  slot;
  FT_Matrix     matrix;              <span class="comment">/* transformation matrix */</span>
  FT_UInt       glyph_index;
  FT_Vector     pen;                 <span class="comment">/* untransformed origin */</span>
  int           n;


  ... initialize library ...
  ... create face object ...
  ... set character size ...

  slot = face-&gt;glyph;                <span class="comment">/* a small shortcut */</span>

  <span class="comment">/* set up matrix */</span>
  matrix.xx = (FT_Fixed)( cos( angle ) * 0x10000L );
  matrix.xy = (FT_Fixed)(-sin( angle ) * 0x10000L );
  matrix.yx = (FT_Fixed)( sin( angle ) * 0x10000L );
  matrix.yy = (FT_Fixed)( cos( angle ) * 0x10000L );

  <span class="comment">/* the pen position in 26.6 cartesian space coordinates */</span>
  <span class="comment">/* start at (300,200)                                   */</span>
  pen.x = 300 * 64;
  pen.y = ( my_target_height - 200 ) * 64;

  for ( n = 0; n &lt; num_chars; n++ )
  {
    <span class="comment">/* set transformation */</span>
    FT_Set_Transform( face, &amp;matrix, &amp;pen );

    <span class="comment">/* load glyph image into the slot (erase previous one) */</span>
    error = FT_Load_Char( face, text[n], FT_LOAD_RENDER );
    if ( error )
      continue;  <span class="comment">/* ignore errors */</span>

    <span class="comment">/* now, draw to our target surface (convert position) */</span>
    my_draw_bitmap( &amp;slot-&gt;bitmap,
                    slot-&gt;bitmap_left,
                    my_target_height - slot-&gt;bitmap_top );

    <span class="comment">/* increment pen position */</span>
    pen.x += slot-&gt;advance.x;
    pen.y += slot-&gt;advance.y;
  }
    </div>

    <p>Some remarks:</p>

    <ul>
      <li>
        <p>We now use a vector of type <tt>FT_Vector</tt> to store the pen
        position, with coordinates expressed as 1/64th of pixels, hence a
        multiplication.  The position is expressed in cartesian space.</p>
      </li>

      <li>
        <p>Glyph images are always loaded, transformed, and described in the
        cartesian coordinate system in FreeType (which means that
        increasing&nbsp;Y corresponds to upper scanlines), unlike the system
        typically used for bitmaps (where the topmost scanline has
        coordinate&nbsp;0).  We must thus convert between the two systems
        when we define the pen position, and when we compute the topleft
        position of the bitmap.</p>
      </li>

      <li>
        <p>We set the transformation on each glyph to indicate the rotation
        matrix as well as a delta that will move the transformed image to
        the current pen position (in cartesian space, not bitmap space).</p>

        <p>As a consequence, the values of <tt>bitmap_left</tt> and
        <tt>bitmap_top</tt> correspond to the bitmap origin in target space
        pixels.  We thus don't add <tt>pen.x</tt> or <tt>pen.y</tt> to their
        values when calling <tt>my_draw_bitmap</tt>.</p>
      </li>

      <li>
        <p>The advance width is always returned transformed, which is why it
        can be directly added to the current pen position.  Note that it is
        <em>not</em> rounded this time.</p>
      </li>
    </ul>

    <p>A complete source code example can be found
    <a href="example1.c">here</a>.</p>

    <p>It is important to note that, while this example is a bit more
    complex than the previous one, it is strictly equivalent for the case
    where the transform is the identity.  Hence it can be used as a
    replacement (but a more powerful one).</p>

    <p>It has however a few shortcomings that we will explain, and solve, in
    the next part of this tutorial.</p>

    <hr>

    <h3>
      Conclusion
    </h3>

    <p>In this first section, you have learned the basics of
    FreeType&nbsp;2, as well as sufficient knowledge how to render rotated
    text.</p>

    <p>The next section will dive into more details of the API in order
    to let you access glyph metrics and images directly, as well as
    how to deal with scaling, hinting, kerning, etc.</p>

    <p>The third section will discuss issues like modules, caching and a few
    other advanced topics like how to use multiple size objects with a
    single face.  [This part hasn't been written yet.]</p>

</td></tr>
</table>
</center>

<h3 align=center>
  <a href="step2.html">FreeType&nbsp;2 Tutorial Step&nbsp;2</a>
</h3>

<p><font size=-3>Last update: 03-May-2007</font></p>

</body>
</html>
